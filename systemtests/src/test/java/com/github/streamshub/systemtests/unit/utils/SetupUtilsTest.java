package com.github.streamshub.systemtests.unit.utils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.github.streamshub.systemtests.Environment;
import com.github.streamshub.systemtests.utils.ResourceUtils;
import com.github.streamshub.systemtests.utils.SetupUtils;
import io.fabric8.kubernetes.api.model.Namespace;
import io.fabric8.kubernetes.api.model.Secret;
import io.fabric8.kubernetes.api.model.SecretBuilder;
import io.skodjob.testframe.clients.KubeClient;
import io.skodjob.testframe.resources.KubeResourceManager;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.powermock.reflect.Whitebox;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.clearInvocations;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class SetupUtilsTest {

    private static MockedStatic<KubeResourceManager> staticMockKubeResourceManager;
    private static MockedStatic<ResourceUtils> staticMockResourceUtils;
    MockedStatic<Environment> staticMockEnvironment;
    private static final KubeResourceManager MOCKED_KUBE_RESOURCE_MANAGER = mock(KubeResourceManager.class);
    private static final KubeClient MOCKED_KUBE_CLIENT = mock(KubeClient.class);


    @BeforeEach
    void setup() {
        staticMockKubeResourceManager = mockStatic(KubeResourceManager.class);
        staticMockKubeResourceManager.when(KubeResourceManager::get).thenReturn(MOCKED_KUBE_RESOURCE_MANAGER);
        when(MOCKED_KUBE_RESOURCE_MANAGER.kubeClient()).thenReturn(MOCKED_KUBE_CLIENT);
        staticMockResourceUtils = mockStatic(ResourceUtils.class);
        staticMockEnvironment = mockStatic(Environment.class);
    }

    @AfterEach
    void tearDown() {
        staticMockKubeResourceManager.close();
        staticMockResourceUtils.close();
        staticMockEnvironment.close();
    }

    @Test
    void testGetYamlFileContent() {
        String invalidUrl = "http://very-invalid-123.cy/test.yaml";
        String validUrl = "https://github.com/streamshub/console/releases/download/0.6.3/streamshub-console-operator.yaml";

        Exception exception = assertThrows(RuntimeException.class, () -> SetupUtils.getYamlFileContent(invalidUrl));
        assertTrue(exception.getMessage().contains("Cannot download YAML content"));

        assertTrue(SetupUtils.getYamlFileContent(validUrl).startsWith("# Generated by Fabric8 CRDGenerator, manual edits might get overwritten!"));
    }

    private static class TestConfig {
        public String key;
    }

    @Test
    void testConfigFromYaml() throws IOException {
        File yamlFile = Files.createTempFile("test-config", ".yaml").toFile();
        Files.write(yamlFile.toPath(), "key: superValue".getBytes());

        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        TestConfig config = SetupUtils.configFromYaml(yamlFile, TestConfig.class);

        assertNotNull(config);
        assertEquals("superValue", config.key);
    }


    @Test
    void testCopyImagePullSecrets_withEnv() {
        String secretName = "test-secret-name";
        String targetNamespace = "target-namespace-name";

        Whitebox.setInternalState(Environment.class, "TEST_CLIENTS_IMAGE_PULL_SECRET", secretName);
        assertEquals(secretName, Environment.TEST_CLIENTS_IMAGE_PULL_SECRET);

        staticMockResourceUtils.when(() -> ResourceUtils.getKubeResource(Secret.class, "default", Environment.TEST_CLIENTS_IMAGE_PULL_SECRET))
            .thenReturn(null);
        assertThrows(RuntimeException.class, () -> SetupUtils.copyImagePullSecrets(targetNamespace));

        staticMockResourceUtils.when(() -> ResourceUtils.getKubeResource(Secret.class, "default", Environment.TEST_CLIENTS_IMAGE_PULL_SECRET))
            .thenReturn(new SecretBuilder().build());
        SetupUtils.copyImagePullSecrets(targetNamespace);
        verify(MOCKED_KUBE_RESOURCE_MANAGER, times(1)).createResourceWithWait(any(Secret.class));
        clearInvocations(MOCKED_KUBE_RESOURCE_MANAGER);

        staticMockResourceUtils.when(() -> ResourceUtils.getKubeResource(Secret.class, targetNamespace, Environment.TEST_CLIENTS_IMAGE_PULL_SECRET))
            .thenReturn(new SecretBuilder().build());
        SetupUtils.copyImagePullSecrets(targetNamespace);
        verify(MOCKED_KUBE_RESOURCE_MANAGER, times(0)).createResourceWithWait(any(Secret.class));

        staticMockResourceUtils.when(() -> ResourceUtils.getKubeResource(Secret.class, targetNamespace, Environment.TEST_CLIENTS_IMAGE_PULL_SECRET))
            .thenReturn(null);
        SetupUtils.copyImagePullSecrets(targetNamespace);
        verify(MOCKED_KUBE_RESOURCE_MANAGER, times(1)).createResourceWithWait(any(Secret.class));
    }

    @Test
    void testCopyImagePullSecrets_withEmptyEnv() {
        assertEquals("", Environment.TEST_CLIENTS_IMAGE_PULL_SECRET);
        SetupUtils.copyImagePullSecrets("test-namespace");
        verify(MOCKED_KUBE_RESOURCE_MANAGER, times(0)).createResourceWithWait(any(Namespace.class));
    }
}

